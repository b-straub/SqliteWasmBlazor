@page "/TestRunner"
@using SQLiteNET.Opfs.TestApp.Data
@using SQLiteNET.Opfs.TestApp.Models
@using Microsoft.EntityFrameworkCore
@using System.Diagnostics
@inject IDbContextFactory<TodoDbContext> DbContextFactory

<PageTitle>Test Runner</PageTitle>

<div>
    @if (_testsCompleted)
    {
        <h1>All Tests Completed</h1>
        <div>Passed: @_passedCount</div>
        <div>Failed: @_failedCount</div>
        @if (_failedTests.Any())
        {
            <h2>Failed Tests:</h2>
            @foreach (var (name, error) in _failedTests)
            {
                <div style="color: red">
                    <strong>@name</strong>: @error
                </div>
            }
        }
    }
    else
    {
        <h1>Running Tests...</h1>
        <div>Progress: @_completedTests / @_totalTests</div>
    }
</div>

@code {
    private bool _testsCompleted;
    private int _passedCount;
    private int _failedCount;
    private int _completedTests;
    private int _totalTests;
    private List<(string Name, string Error)> _failedTests = new();

    protected override async Task OnInitializedAsync()
    {
        await RunAllTestsAsync();
    }

    private async Task RunAllTestsAsync()
    {
        var tests = new List<Func<Task>>
        {
            // Type Marshalling Tests
            () => RunTestAsync("AllTypes_RoundTrip", AllTypes_RoundTripAsync),
            () => RunTestAsync("IntegerTypes_Boundaries", IntegerTypes_BoundariesAsync),
            () => RunTestAsync("NullableTypes_AllNull", NullableTypes_AllNullAsync),
            () => RunTestAsync("BinaryData_LargeBlob", BinaryData_LargeBlobAsync),
            () => RunTestAsync("StringValue_Unicode", StringValue_UnicodeAsync),

            // JSON Collection Tests
            () => RunTestAsync("IntList_RoundTrip", IntList_RoundTripAsync),
            () => RunTestAsync("IntList_Empty", IntList_EmptyAsync),
            () => RunTestAsync("IntList_LargeCollection", IntList_LargeCollectionAsync),

            // CRUD Tests
            () => RunTestAsync("Create_SingleEntity", Create_SingleEntityAsync),
            () => RunTestAsync("Read_ById", Read_ByIdAsync),
            () => RunTestAsync("Update_ModifyProperty", Update_ModifyPropertyAsync),
            () => RunTestAsync("Delete_SingleEntity", Delete_SingleEntityAsync),
            () => RunTestAsync("BulkInsert_100Entities", BulkInsert_100EntitiesAsync),

            // Transaction Tests
            () => RunTestAsync("Transaction_Commit", Transaction_CommitAsync),
            () => RunTestAsync("Transaction_Rollback", Transaction_RollbackAsync),
        };

        _totalTests = tests.Count;

        foreach (var test in tests)
        {
            await test();
            _completedTests++;
            StateHasChanged();
        }

        _testsCompleted = true;
        StateHasChanged();
    }

    private async Task RunTestAsync(string name, Func<Task> testFunc)
    {
        try
        {
            await testFunc();
            _passedCount++;
        }
        catch (Exception ex)
        {
            _failedCount++;
            _failedTests.Add((name, ex.Message));
        }
    }

    // ===== TYPE MARSHALLING TESTS =====

    private async Task AllTypes_RoundTripAsync()
    {
        await using var context = await DbContextFactory.CreateDbContextAsync();

        var entity = new TypeTestEntity
        {
            ByteValue = 255,
            ShortValue = -32768,
            IntValue = int.MaxValue,
            LongValue = long.MaxValue,
            FloatValue = 3.14159f,
            DoubleValue = Math.PI,
            DecimalValue = 123456.789m,
            BoolValue = true,
            StringValue = "Test String with √©mojis üöÄ",
            DateTimeValue = DateTime.UtcNow,
            GuidValue = Guid.NewGuid(),
            BlobValue = new byte[] { 0x00, 0x01, 0x02, 0xFF, 0xFE, 0xFD },
            EnumValue = TestEnum.Second,
            CharValue = 'A',
            IntList = new List<int> { 1, 2, 3, 42, 100 }
        };

        context.TypeTests.Add(entity);
        await context.SaveChangesAsync();

        var retrieved = await context.TypeTests.FindAsync(entity.Id);
        if (retrieved is null) throw new Exception("Failed to retrieve entity");

        if (retrieved.ByteValue != entity.ByteValue) throw new Exception("ByteValue mismatch");
        if (retrieved.IntValue != entity.IntValue) throw new Exception("IntValue mismatch");
        if (retrieved.LongValue != entity.LongValue) throw new Exception("LongValue mismatch");
        if (Math.Abs(retrieved.FloatValue - entity.FloatValue) > 0.0001f) throw new Exception("FloatValue mismatch");
        if (retrieved.DecimalValue != entity.DecimalValue) throw new Exception("DecimalValue mismatch");
        if (retrieved.BoolValue != entity.BoolValue) throw new Exception("BoolValue mismatch");
        if (retrieved.StringValue != entity.StringValue) throw new Exception("StringValue mismatch");
        if (retrieved.GuidValue != entity.GuidValue) throw new Exception("GuidValue mismatch");
        if (!retrieved.BlobValue!.SequenceEqual(entity.BlobValue)) throw new Exception("BlobValue mismatch");
        if (retrieved.EnumValue != entity.EnumValue) throw new Exception("EnumValue mismatch");
        if (retrieved.CharValue != entity.CharValue) throw new Exception("CharValue mismatch");
        if (!retrieved.IntList.SequenceEqual(entity.IntList)) throw new Exception("IntList mismatch");
    }

    private async Task IntegerTypes_BoundariesAsync()
    {
        await using var context = await DbContextFactory.CreateDbContextAsync();

        var entity = new TypeTestEntity
        {
            ByteValue = byte.MaxValue,
            ShortValue = short.MinValue,
            IntValue = int.MinValue,
            LongValue = long.MinValue
        };

        context.TypeTests.Add(entity);
        await context.SaveChangesAsync();

        var retrieved = await context.TypeTests.FindAsync(entity.Id);
        if (retrieved is null) throw new Exception("Failed to retrieve entity");

        if (retrieved.ByteValue != byte.MaxValue) throw new Exception("ByteValue boundary mismatch");
        if (retrieved.ShortValue != short.MinValue) throw new Exception("ShortValue boundary mismatch");
        if (retrieved.IntValue != int.MinValue) throw new Exception("IntValue boundary mismatch");
        if (retrieved.LongValue != long.MinValue) throw new Exception("LongValue boundary mismatch");
    }

    private async Task NullableTypes_AllNullAsync()
    {
        await using var context = await DbContextFactory.CreateDbContextAsync();

        var entity = new TypeTestEntity
        {
            NullableByteValue = null,
            NullableIntValue = null,
            NullableStringValue = null,
            NullableGuidValue = null
        };

        context.TypeTests.Add(entity);
        await context.SaveChangesAsync();

        var retrieved = await context.TypeTests.FindAsync(entity.Id);
        if (retrieved is null) throw new Exception("Failed to retrieve entity");

        if (retrieved.NullableByteValue is not null) throw new Exception("NullableByteValue should be null");
        if (retrieved.NullableIntValue is not null) throw new Exception("NullableIntValue should be null");
        if (retrieved.NullableStringValue is not null) throw new Exception("NullableStringValue should be null");
        if (retrieved.NullableGuidValue is not null) throw new Exception("NullableGuidValue should be null");
    }

    private async Task BinaryData_LargeBlobAsync()
    {
        await using var context = await DbContextFactory.CreateDbContextAsync();

        var largeBlob = new byte[1024 * 100]; // 100KB
        new Random(42).NextBytes(largeBlob);

        var entity = new TypeTestEntity { BlobValue = largeBlob };

        context.TypeTests.Add(entity);
        await context.SaveChangesAsync();

        var retrieved = await context.TypeTests.FindAsync(entity.Id);
        if (retrieved is null) throw new Exception("Failed to retrieve entity");
        if (retrieved.BlobValue is null) throw new Exception("BlobValue is null");
        if (retrieved.BlobValue.Length != largeBlob.Length) throw new Exception("BlobValue length mismatch");
        if (!retrieved.BlobValue.SequenceEqual(largeBlob)) throw new Exception("BlobValue content mismatch");
    }

    private async Task StringValue_UnicodeAsync()
    {
        await using var context = await DbContextFactory.CreateDbContextAsync();

        var entity = new TypeTestEntity
        {
            StringValue = "Hello ‰∏ñÁïå üåç –ü—Ä–∏–≤–µ—Ç ŸÖÿ±ÿ≠ÿ®ÿß"
        };

        context.TypeTests.Add(entity);
        await context.SaveChangesAsync();

        var retrieved = await context.TypeTests.FindAsync(entity.Id);
        if (retrieved is null) throw new Exception("Failed to retrieve entity");
        if (retrieved.StringValue != entity.StringValue) throw new Exception("Unicode string mismatch");
    }

    // ===== JSON COLLECTION TESTS =====

    private async Task IntList_RoundTripAsync()
    {
        await using var context = await DbContextFactory.CreateDbContextAsync();

        var entity = new TypeTestEntity
        {
            IntList = new List<int> { 1, 2, 3, 42, 100, -5, 0 }
        };

        context.TypeTests.Add(entity);
        await context.SaveChangesAsync();

        var retrieved = await context.TypeTests.FindAsync(entity.Id);
        if (retrieved is null) throw new Exception("Failed to retrieve entity");
        if (!retrieved.IntList.SequenceEqual(entity.IntList)) throw new Exception("IntList mismatch");
    }

    private async Task IntList_EmptyAsync()
    {
        await using var context = await DbContextFactory.CreateDbContextAsync();

        var entity = new TypeTestEntity { IntList = new List<int>() };

        context.TypeTests.Add(entity);
        await context.SaveChangesAsync();

        var retrieved = await context.TypeTests.FindAsync(entity.Id);
        if (retrieved is null) throw new Exception("Failed to retrieve entity");
        if (retrieved.IntList.Count != 0) throw new Exception("IntList should be empty");
    }

    private async Task IntList_LargeCollectionAsync()
    {
        await using var context = await DbContextFactory.CreateDbContextAsync();

        var largeList = Enumerable.Range(1, 1000).ToList();
        var entity = new TypeTestEntity { IntList = largeList };

        context.TypeTests.Add(entity);
        await context.SaveChangesAsync();

        var retrieved = await context.TypeTests.FindAsync(entity.Id);
        if (retrieved is null) throw new Exception("Failed to retrieve entity");
        if (retrieved.IntList.Count != 1000) throw new Exception("IntList count mismatch");
        if (!retrieved.IntList.SequenceEqual(largeList)) throw new Exception("IntList content mismatch");
    }

    // ===== CRUD TESTS =====

    private async Task Create_SingleEntityAsync()
    {
        await using var context = await DbContextFactory.CreateDbContextAsync();

        var item = new TodoItem
        {
            Title = "Test Todo",
            Description = "Test Description",
            IsCompleted = false,
            CreatedAt = DateTime.UtcNow
        };

        context.TodoItems.Add(item);
        await context.SaveChangesAsync();

        if (item.Id <= 0) throw new Exception("ID was not generated");
    }

    private async Task Read_ByIdAsync()
    {
        await using var context = await DbContextFactory.CreateDbContextAsync();

        var item = new TodoItem
        {
            Title = "Findable Todo",
            Description = "Test",
            CreatedAt = DateTime.UtcNow
        };

        context.TodoItems.Add(item);
        await context.SaveChangesAsync();

        var found = await context.TodoItems.FindAsync(item.Id);
        if (found is null) throw new Exception("Failed to find entity");
        if (found.Title != "Findable Todo") throw new Exception("Title mismatch");
    }

    private async Task Update_ModifyPropertyAsync()
    {
        int itemId;

        // Create entity
        await using (var context = await DbContextFactory.CreateDbContextAsync())
        {
            var item = new TodoItem
            {
                Title = "Original Title",
                Description = "Original Description",
                CreatedAt = DateTime.UtcNow
            };

            context.TodoItems.Add(item);
            await context.SaveChangesAsync();
            itemId = item.Id;
            Console.WriteLine($"[Update_ModifyProperty] Created item with Id={itemId}");
        }

        // Update in separate context
        await using (var updateContext = await DbContextFactory.CreateDbContextAsync())
        {
            var itemToUpdate = await updateContext.TodoItems.FindAsync(itemId);
            if (itemToUpdate is null) throw new Exception("Failed to find item for update");

            Console.WriteLine($"[Update_ModifyProperty] Found item: Id={itemToUpdate.Id}, Title={itemToUpdate.Title}");
            Console.WriteLine($"[Update_ModifyProperty] Entity state before modification: {updateContext.Entry(itemToUpdate).State}");

            itemToUpdate.Title = "Updated Title";
            itemToUpdate.Description = "Updated Description";

            Console.WriteLine($"[Update_ModifyProperty] Entity state after modification: {updateContext.Entry(itemToUpdate).State}");
            Console.WriteLine($"[Update_ModifyProperty] About to SaveChangesAsync...");

            await updateContext.SaveChangesAsync();

            Console.WriteLine($"[Update_ModifyProperty] SaveChangesAsync completed");
        }

        // Verify with fresh context
        await using (var verifyContext = await DbContextFactory.CreateDbContextAsync())
        {
            var updated = await verifyContext.TodoItems.FindAsync(itemId);
            if (updated is null) throw new Exception("Failed to find updated entity");
            if (updated.Title != "Updated Title") throw new Exception("Title not updated");
            if (updated.Description != "Updated Description") throw new Exception("Description not updated");
        }
    }

    private async Task Delete_SingleEntityAsync()
    {
        await using var context = await DbContextFactory.CreateDbContextAsync();

        var item = new TodoItem
        {
            Title = "To Delete",
            Description = "Test",
            CreatedAt = DateTime.UtcNow
        };

        context.TodoItems.Add(item);
        await context.SaveChangesAsync();

        var id = item.Id;

        context.TodoItems.Remove(item);
        await context.SaveChangesAsync();

        var deleted = await context.TodoItems.FindAsync(id);
        if (deleted is not null) throw new Exception("Entity was not deleted");
    }

    private async Task BulkInsert_100EntitiesAsync()
    {
        await using var context = await DbContextFactory.CreateDbContextAsync();

        var items = Enumerable.Range(1, 100)
            .Select(i => new TodoItem
            {
                Title = $"Item {i}",
                Description = $"Description {i}",
                CreatedAt = DateTime.UtcNow
            })
            .ToList();

        context.TodoItems.AddRange(items);
        await context.SaveChangesAsync();

        var count = await context.TodoItems.CountAsync();
        if (count < 100) throw new Exception($"Expected at least 100 items, got {count}");
    }

    // ===== TRANSACTION TESTS =====

    private async Task Transaction_CommitAsync()
    {
        await using var context = await DbContextFactory.CreateDbContextAsync();

        await using var transaction = await context.Database.BeginTransactionAsync();

        var item = new TodoItem
        {
            Title = "Transaction Test",
            Description = "Test",
            CreatedAt = DateTime.UtcNow
        };

        context.TodoItems.Add(item);
        await context.SaveChangesAsync();

        await transaction.CommitAsync();

        var found = await context.TodoItems.FindAsync(item.Id);
        if (found is null) throw new Exception("Transaction commit failed");
    }

    private async Task Transaction_RollbackAsync()
    {
        int initialCount;

        // Get initial count
        await using (var context = await DbContextFactory.CreateDbContextAsync())
        {
            initialCount = await context.TodoItems.CountAsync();
        }

        // Try to add item in transaction and rollback
        await using (var context = await DbContextFactory.CreateDbContextAsync())
        {
            await using var transaction = await context.Database.BeginTransactionAsync();

            var item = new TodoItem
            {
                Title = "Rollback Test",
                Description = "Test",
                CreatedAt = DateTime.UtcNow
            };

            context.TodoItems.Add(item);
            await context.SaveChangesAsync();

            await transaction.RollbackAsync();
        }

        // Verify count in fresh context
        await using (var verifyContext = await DbContextFactory.CreateDbContextAsync())
        {
            var finalCount = await verifyContext.TodoItems.CountAsync();
            if (finalCount != initialCount) throw new Exception($"Transaction rollback failed: expected {initialCount}, got {finalCount}");
        }
    }
}
