@inject ISnackbar Snackbar
@inject IJSRuntime JS
@implements IAsyncDisposable

@code {
    private DotNetObjectReference<ServiceWorkerUpdateNotification>? _objRef;
    private Snackbar? _updateSnackbar;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _objRef = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("ServiceWorkerUpdate.registerUpdateCallback", _objRef);
        }
    }

    [JSInvokable]
    public void OnUpdateAvailable()
    {
        _updateSnackbar = Snackbar.Add(
            @<div>
                <MudStack Spacing="2">
                    <MudText Typo="Typo.body2">An update for this application is available!</MudText>
                    <MudAlert Severity="Severity.Warning" Dense="true" Class="pa-2">
                        <MudText Typo="Typo.caption">
                            <strong>Demo Notice:</strong> If you encounter any issues after updating, please use "Reset Database" from the TodoList page.
                        </MudText>
                    </MudAlert>
                    <MudButton Variant="Variant.Filled" Color="Color.Primary" OnClick="UpdateApp">Update</MudButton>
                </MudStack>
            </div>,
            Severity.Info,
            config =>
            {
                config.RequireInteraction = true;
                config.DuplicatesBehavior = SnackbarDuplicatesBehavior.Prevent;
            });
    }

    private async Task UpdateApp()
    {
        if (_updateSnackbar is not null)
        {
            Snackbar.Remove(_updateSnackbar);
            _updateSnackbar = null;
        }

        await JS.InvokeVoidAsync("ServiceWorkerUpdate.skipWaitingAndReload");
    }

    public async ValueTask DisposeAsync()
    {
        if (_objRef is not null)
        {
            await JS.InvokeVoidAsync("ServiceWorkerUpdate.registerUpdateCallback", null);
            _objRef.Dispose();
        }
    }
}
