@using Microsoft.EntityFrameworkCore
@using SqliteWasmBlazor
@using SqliteWasmBlazor.Models
@using SqliteWasmBlazor.Models.DTOs
@using SqliteWasmBlazor.Models.Extensions
@using SqliteWasmBlazor.Models.Enums
@using SqliteWasmBlazor.Models.Models
@using SqliteWasmBlazor.Components.Components
@using System.Runtime.Versioning
@inject IDbContextFactory<TodoDbContext> DbContextFactory
@inject ISnackbar Snackbar
@inject ILogger<TodoImportExport> Logger
@implements IAsyncDisposable

<MudPaper Elevation="2" Class="pa-4 mb-6">
    <MudStack Spacing="3">
        <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
            <MudText Typo="Typo.h6">
                <MudIcon Icon="@Icons.Material.Filled.ImportExport" Size="Size.Small" Class="mr-1" />
                Database Import/Export
            </MudText>
            <MudButtonGroup Size="Size.Small" OverrideStyles="false">
                <MudButton OnClick="@(() => SetExportMode(ExportMode.Full))"
                          Color="@(_exportMode == ExportMode.Full ? Color.Primary : Color.Default)"
                          Variant="@(_exportMode == ExportMode.Full ? Variant.Filled : Variant.Outlined)">
                    Full
                </MudButton>
                <MudButton OnClick="@(() => SetExportMode(ExportMode.Delta))"
                          Color="@(_exportMode == ExportMode.Delta ? Color.Primary : Color.Default)"
                          Variant="@(_exportMode == ExportMode.Delta ? Variant.Filled : Variant.Outlined)">
                    Delta
                </MudButton>
            </MudButtonGroup>
        </MudStack>

        @if (_exportMode == ExportMode.Delta)
        {
            <MudPaper Elevation="0" Class="pa-3 mb-3" Style="background-color: var(--mud-palette-info);">
                <MudStack Spacing="2">
                    <MudText Typo="Typo.subtitle2">Delta Export Info</MudText>
                    <MudText Typo="Typo.body2">
                        Exports only items changed since last delta export (including soft-deleted items for sync).
                    </MudText>
                </MudStack>
            </MudPaper>

            <MudPaper Elevation="0" Class="pa-3" Style="background-color: var(--mud-palette-background-grey);">
                <MudStack Spacing="2">
                    <MudText Typo="Typo.subtitle2">Conflict Resolution Strategy</MudText>
                    <MudText Typo="Typo.caption" Color="Color.Secondary">
                        Choose how to handle conflicts when importing delta data with existing local changes
                    </MudText>
                    <MudRadioGroup @bind-Value="_conflictResolution">
                        <MudRadio T="ConflictResolutionStrategy" Value="ConflictResolutionStrategy.LastWriteWins" Color="Color.Primary">
                            <MudStack Spacing="0">
                                <MudText Typo="Typo.body2"><strong>Last Write Wins</strong></MudText>
                                <MudText Typo="Typo.caption">Most recent timestamp wins (compares UpdatedAt)</MudText>
                            </MudStack>
                        </MudRadio>
                        <MudRadio T="ConflictResolutionStrategy" Value="ConflictResolutionStrategy.LocalWins" Color="Color.Success">
                            <MudStack Spacing="0">
                                <MudText Typo="Typo.body2"><strong>Local Wins</strong></MudText>
                                <MudText Typo="Typo.caption">Keep local changes, only add new items from import</MudText>
                            </MudStack>
                        </MudRadio>
                        <MudRadio T="ConflictResolutionStrategy" Value="ConflictResolutionStrategy.DeltaWins" Color="Color.Warning">
                            <MudStack Spacing="0">
                                <MudText Typo="Typo.body2"><strong>Delta Wins</strong></MudText>
                                <MudText Typo="Typo.caption">Accept all imported changes, overwrite local items</MudText>
                            </MudStack>
                        </MudRadio>
                    </MudRadioGroup>
                </MudStack>
            </MudPaper>
        }

        <MudGrid Spacing="3">
            <MudItem xs="12" sm="6">
                <MessagePackFileDownload T="TodoItemDto"
                    GetPageAsync="@GetTodoItemsPageAsync"
                    GetTotalCountAsync="@GetTodoItemCountAsync"
                    FileName="@GetExportFileName()"
                    ButtonText="@GetExportButtonText()"
                    PageSize="10000"
                    AppIdentifier="@AppIdentifier"
                    OnDownloadStarted="@OnExportStarted"
                    OnDownloadCompleted="@OnExportCompleted" />
            </MudItem>

            <MudItem xs="12" sm="6">
                <MessagePackFileUpload T="TodoItemDto"
                    OnBulkInsertAsync="@GetImportMethodAsync()"
                    ButtonText="@GetImportButtonText()"
                    BatchSize="10000"
                    ExpectedSchemaHash="@_schemaHash"
                    ExpectedAppIdentifier="@AppIdentifier"
                    OnUploadStarted="@OnImportStartedAsync"
                    OnUploadCompleted="@OnImportCompletedAsync"
                    OnUploadFailed="@OnImportFailed" />
            </MudItem>
        </MudGrid>

        <MudAlert Severity="@GetAlertSeverity()" Dense="true" NoIcon="false">
            @GetModeDescription()
        </MudAlert>

        @if (_showTombstoneCleanup && _tombstoneCount > 0)
        {
            <MudPaper Elevation="0" Class="pa-3" Style="background-color: var(--mud-palette-success);">
                <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
                    <MudStack Spacing="1">
                        <MudText Typo="Typo.subtitle2">Delta Sync Complete!</MudText>
                        <MudText Typo="Typo.body2">
                            @_tombstoneCount soft-deleted item(s) ready for cleanup.
                        </MudText>
                    </MudStack>
                    <MudButton Color="Color.Success"
                              Variant="Variant.Filled"
                              OnClick="@CleanTombstonesAsync"
                              StartIcon="@Icons.Material.Filled.CleaningServices">
                        Clean Tombstones
                    </MudButton>
                </MudStack>
            </MudPaper>
        }
    </MudStack>
</MudPaper>

@code {
    /// <summary>
    /// Database filename (without path) - e.g., "TodoDb.db"
    /// </summary>
    [Parameter]
    public string DatabaseName { get; set; } = "TodoDb.db";

    [Parameter]
    public EventCallback OnDataChanged { get; set; }

    /// <summary>
    /// Application identifier to prevent cross-app data imports
    /// </summary>
    private const string AppIdentifier = "SqliteWasmBlazor.Demo";

    /// <summary>
    /// Schema hash computed from TodoItemDto structure (automatic validation)
    /// </summary>
    private readonly string _schemaHash = SqliteWasmBlazor.Components.Interop.SchemaHashGenerator.ComputeHash<TodoItemDto>();

    private TodoDbContext? _tempDbContext;
    private Microsoft.EntityFrameworkCore.Storage.IDbContextTransaction? _importTransaction;
    private bool _isImporting;
    private int _importedCount;
    private ExportMode _exportMode = ExportMode.Full;
    private ConflictResolutionStrategy _conflictResolution = ConflictResolutionStrategy.LastWriteWins;
    private bool _showTombstoneCleanup;
    private int _tombstoneCount;

    private string ImportDatabaseName => $"{Path.GetFileNameWithoutExtension(DatabaseName)}-import{Path.GetExtension(DatabaseName)}";
    private string BackupDatabaseName => $"{Path.GetFileNameWithoutExtension(DatabaseName)}.bak";

    private void SetExportMode(ExportMode mode)
    {
        _exportMode = mode;
        _showTombstoneCleanup = false; // Reset cleanup banner when switching modes
        StateHasChanged();
    }

    private string GetExportButtonText()
    {
        return _exportMode == ExportMode.Full
            ? "Export All TodoItems"
            : "Export Delta (Changed Items)";
    }

    private string GetImportButtonText()
    {
        return _exportMode == ExportMode.Full
            ? "Import TodoItems (Replace All)"
            : "Import Delta (Merge/Update)";
    }

    private Severity GetAlertSeverity()
    {
        return _exportMode == ExportMode.Full ? Severity.Warning : Severity.Info;
    }

    private string GetModeDescription()
    {
        if (_exportMode == ExportMode.Full)
        {
            return "Full mode: Import will create a temporary database and swap it after validation. Your current data will be backed up as " + BackupDatabaseName;
        }
        else
        {
            var strategyDesc = _conflictResolution switch
            {
                ConflictResolutionStrategy.LastWriteWins => "Most recent changes win (compares timestamps)",
                ConflictResolutionStrategy.LocalWins => "Local changes always win (only new items are added)",
                ConflictResolutionStrategy.DeltaWins => "Imported changes always win (local items overwritten)",
                _ => ""
            };
            return $"Delta mode: Import will merge/update items. Conflict resolution: {strategyDesc}";
        }
    }

    private Func<List<TodoItemDto>, Task> GetImportMethodAsync()
    {
        return _exportMode == ExportMode.Full
            ? BulkInsertTodoItemsAsync
            : DeltaMergeTodoItemsAsync;
    }

    // Export methods
    private async Task<List<TodoItemDto>> GetTodoItemsPageAsync(int pageIndex, int pageSize)
    {
        await using var context = await DbContextFactory.CreateDbContextAsync();

        if (_exportMode == ExportMode.Full)
        {
            // Full export: exclude soft-deleted items
            var query = context.TodoItems.AsNoTracking()
                .Where(t => !t.IsDeleted);

            var items = await query
                .OrderByDescending(t => t.UpdatedAt)
                .Skip(pageIndex * pageSize)
                .Take(pageSize)
                .ToListAsync();

            return items.Select(TodoItemDto.FromEntity).ToList();
        }
        else
        {
            // Delta export: get items changed since last checkpoint (including soft-deleted)
            var latestCheckpoint = await context.SyncState
                .OrderByDescending(s => s.Id)
                .FirstOrDefaultAsync();
            var lastExportAt = latestCheckpoint?.CreatedAt ?? DateTime.MinValue;

            var items = await context.TodoItems.AsNoTracking()
                .Where(t =>
                    (t.UpdatedAt > lastExportAt && !t.IsDeleted) ||
                    (t.IsDeleted && t.DeletedAt > lastExportAt))
                .OrderByDescending(t => t.UpdatedAt)
                .Skip(pageIndex * pageSize)
                .Take(pageSize)
                .ToListAsync();

            return items.Select(TodoItemDto.FromEntity).ToList();
        }
    }

    private async Task<int> GetTodoItemCountAsync()
    {
        await using var context = await DbContextFactory.CreateDbContextAsync();

        if (_exportMode == ExportMode.Full)
        {
            // Full export: count only active (non-deleted) items
            return await context.TodoItems
                .Where(t => !t.IsDeleted)
                .CountAsync();
        }
        else
        {
            // Delta export: count items changed since last checkpoint (including soft-deleted)
            var latestCheckpoint = await context.SyncState
                .OrderByDescending(s => s.Id)
                .FirstOrDefaultAsync();
            var lastExportAt = latestCheckpoint?.CreatedAt ?? DateTime.MinValue;

            return await context.TodoItems
                .Where(t =>
                    (t.UpdatedAt > lastExportAt && !t.IsDeleted) ||
                    (t.IsDeleted && t.DeletedAt > lastExportAt))
                .CountAsync();
        }
    }

    private string GetExportFileName()
    {
        var timestamp = DateTime.Now.ToString("yyyyMMdd-HHmmss");
        var prefix = _exportMode == ExportMode.Full ? "todoitems-full" : "todoitems-delta";
        return $"{prefix}-{timestamp}.msgpack";
    }

    private async Task OnExportStarted()
    {
        Logger.LogDebug("Export started");
        await Task.CompletedTask;
    }

    private async Task OnExportCompleted(int count)
    {
        Logger.LogInformation("Export completed: {Count} items", count);

        // Create checkpoint after delta export
        if (_exportMode == ExportMode.Delta && count > 0)
        {
            try
            {
                await using var context = await DbContextFactory.CreateDbContextAsync();

                // Create checkpoint after delta export
                var checkpoint = await context.CreateCheckpointAsync(
                    $"Auto checkpoint after delta export ({count} items)",
                    "Auto");

                Logger.LogInformation("Created checkpoint at {CheckpointTime} with {ActiveCount} active items, {TombstoneCount} tombstones",
                    checkpoint.CreatedAt, checkpoint.ActiveItemCount, checkpoint.TombstoneCount);

                // Check for tombstones and offer cleanup
                _tombstoneCount = checkpoint.TombstoneCount;
                if (_tombstoneCount > 0)
                {
                    _showTombstoneCleanup = true;
                    Logger.LogInformation("Found {TombstoneCount} tombstones ready for cleanup", _tombstoneCount);
                }

                // Trigger UI refresh to update checkpoint display in parent component
                await OnDataChanged.InvokeAsync();
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Failed to create checkpoint after delta export");
                Snackbar.Add("Warning: Failed to create checkpoint", Severity.Warning);
            }
        }

        Snackbar.Add($"Successfully exported {count:N0} items", Severity.Success);
        StateHasChanged(); // Update UI to show tombstone cleanup banner if needed
    }

    // Import methods
    private async Task OnImportStartedAsync()
    {
        if (_isImporting)
        {
            return;
        }

        _isImporting = true;
        _importedCount = 0;

        // Patch mode doesn't need temp database
        if (_exportMode == ExportMode.Delta)
        {
            Snackbar.Add(
                "Starting patch import - will merge/update items in current database...",
                Severity.Info,
                config =>
                {
                    config.VisibleStateDuration = 3000;
                });
            return;
        }

        // Full mode uses temporary database
        Snackbar.Add(
            "Import will create a temporary database and swap it after validation. Your current data will be backed up.",
            Severity.Warning,
            config =>
            {
                config.VisibleStateDuration = 5000;
            });

        // Create temporary database for import
        try
        {
            // Delete temp database if it exists from previous failed import
            if (await SqliteWasmWorkerBridge.Instance.ExistsDatabaseAsync(ImportDatabaseName))
            {
                Logger.LogDebug("Deleting existing temporary database: {DatabaseName}", ImportDatabaseName);
                await SqliteWasmWorkerBridge.Instance.DeleteDatabaseAsync(ImportDatabaseName);
            }

            var tempConnection = new SqliteWasmConnection($"Data Source={ImportDatabaseName}");
            var optionsBuilder = new DbContextOptionsBuilder<TodoDbContext>();
            optionsBuilder.UseSqliteWasm(tempConnection);

            _tempDbContext = new TodoDbContext(optionsBuilder.Options);

            // Run migrations (includes FTS5 setup)
            await _tempDbContext.Database.MigrateAsync();

            // Start transaction for entire import (improves performance and ensures atomicity)
            _importTransaction = await _tempDbContext.Database.BeginTransactionAsync();

            Logger.LogInformation("Temporary import database created with migrations: {DatabaseName}", ImportDatabaseName);
            Snackbar.Add("Starting import to temporary database...", Severity.Info);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to create temporary database");
            Snackbar.Add($"Failed to create temporary database: {ex.Message}", Severity.Error);
            _isImporting = false;
            _tempDbContext?.Dispose();
            _tempDbContext = null;
            throw;
        }
    }

    private async Task BulkInsertTodoItemsAsync(List<TodoItemDto> dtos)
    {
        if (_tempDbContext is null)
        {
            throw new InvalidOperationException("Temporary database not initialized");
        }

        try
        {
            // Use raw SQL with multi-row INSERT for true batching
            // SQLite supports up to 999 parameters per statement
            // Try to get column count from EF Core metadata, fallback to constant
            const int maxSqliteParams = 999;
            const int defaultColumnCount = 8; // TodoItem: Id, Title, Description, IsCompleted, UpdatedAt, CompletedAt, IsDeleted, DeletedAt

            var entityType = _tempDbContext.Model.FindEntityType(typeof(TodoItem));
            var columnCount = entityType?.GetProperties().Count();

            if (columnCount is null)
            {
                Logger.LogWarning("Unable to retrieve column count from EF Core metadata, using default value {DefaultCount}", defaultColumnCount);
                columnCount = defaultColumnCount;
            }

            var rowsPerBatch = maxSqliteParams / columnCount.Value;

            for (var i = 0; i < dtos.Count; i += rowsPerBatch)
            {
                var batch = dtos.Skip(i).Take(rowsPerBatch).ToList();

                // Build multi-row INSERT statement
                var valuesClauses = new List<string>();
                var parameters = new List<object?>();

                for (var j = 0; j < batch.Count; j++)
                {
                    var dto = batch[j];
                    var baseIndex = j * columnCount;
                    valuesClauses.Add($"({{{baseIndex}}}, {{{baseIndex + 1}}}, {{{baseIndex + 2}}}, {{{baseIndex + 3}}}, {{{baseIndex + 4}}}, {{{baseIndex + 5}}}, {{{baseIndex + 6}}}, {{{baseIndex + 7}}})");

                    parameters.Add(dto.Id.ToByteArray());
                    parameters.Add(dto.Title);
                    parameters.Add(dto.Description);
                    parameters.Add(dto.IsCompleted ? 1 : 0);
                    parameters.Add(dto.UpdatedAt.ToString("O"));
                    parameters.Add(dto.CompletedAt?.ToString("O"));
                    parameters.Add(dto.IsDeleted ? 1 : 0);
                    parameters.Add(dto.DeletedAt?.ToString("O"));
                }

                var sql = $@"
                    INSERT INTO TodoItems (Id, Title, Description, IsCompleted, UpdatedAt, CompletedAt, IsDeleted, DeletedAt)
                    VALUES {string.Join(", ", valuesClauses)}";

                await _tempDbContext.Database.ExecuteSqlRawAsync(sql, parameters.ToArray()!);
            }

            _importedCount += dtos.Count;
            Logger.LogDebug("Imported batch: {BatchCount} items (total: {TotalCount})", dtos.Count, _importedCount);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Batch import failed");
            throw;
        }
    }

    private async Task DeltaMergeTodoItemsAsync(List<TodoItemDto> dtos)
    {
        try
        {
            await using var context = await DbContextFactory.CreateDbContextAsync();

            // Use a transaction for the entire batch for better performance
            await using var transaction = await context.Database.BeginTransactionAsync();

            var updatedCount = 0;
            var insertedCount = 0;
            var deletedCount = 0;

            foreach (var dto in dtos)
            {
                // Check if item exists
                var existingItem = await context.TodoItems.FindAsync(dto.Id);

                if (dto.IsDeleted)
                {
                    // Handle soft deletion
                    if (existingItem is not null && !existingItem.IsDeleted)
                    {
                        existingItem.IsDeleted = true;
                        existingItem.DeletedAt = dto.DeletedAt;
                        deletedCount++;
                    }
                }
                else
                {
                    if (existingItem is not null)
                    {
                        // Apply conflict resolution strategy
                        var shouldUpdate = _conflictResolution switch
                        {
                            ConflictResolutionStrategy.LastWriteWins => dto.UpdatedAt > existingItem.UpdatedAt,
                            ConflictResolutionStrategy.LocalWins => false, // Never update existing items
                            ConflictResolutionStrategy.DeltaWins => true,  // Always update with imported data
                            _ => throw new InvalidOperationException($"Unknown conflict resolution strategy: {_conflictResolution}")
                        };

                        if (shouldUpdate)
                        {
                            existingItem.Title = dto.Title;
                            existingItem.Description = dto.Description;
                            existingItem.IsCompleted = dto.IsCompleted;
                            existingItem.UpdatedAt = dto.UpdatedAt;
                            existingItem.CompletedAt = dto.CompletedAt;
                            existingItem.IsDeleted = dto.IsDeleted;
                            existingItem.DeletedAt = dto.DeletedAt;
                            updatedCount++;
                        }
                    }
                    else
                    {
                        // Insert new item (all strategies add new items)
                        var newItem = dto.ToEntity();
                        context.TodoItems.Add(newItem);
                        insertedCount++;
                    }
                }
            }

            await context.SaveChangesAsync();
            await transaction.CommitAsync();

            _importedCount += dtos.Count;
            Logger.LogDebug("Delta merged batch: {Inserted} inserted, {Updated} updated, {Deleted} deleted (total: {TotalCount})",
                insertedCount, updatedCount, deletedCount, _importedCount);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Delta merge failed");
            throw;
        }
    }

    private async Task OnImportCompletedAsync(int totalCount)
    {
        // Handle patch mode completion
        if (_exportMode == ExportMode.Delta)
        {
            try
            {
                Logger.LogInformation("Delta import completed: {Count} items", totalCount);

                // Check for tombstones after delta import
                await using var context = await DbContextFactory.CreateDbContextAsync();
                _tombstoneCount = await context.TodoItems.CountAsync(t => t.IsDeleted);

                if (_tombstoneCount > 0)
                {
                    _showTombstoneCleanup = true;
                    Logger.LogInformation("Found {TombstoneCount} tombstones after delta import", _tombstoneCount);
                }

                // Create auto checkpoint after delta import
                var checkpoint = await context.CreateCheckpointAsync(
                    $"Auto checkpoint after delta import ({totalCount} items)",
                    "Auto");

                Logger.LogInformation("Created checkpoint after delta import at {CheckpointTime}", checkpoint.CreatedAt);

                Snackbar.Add($"Successfully imported {totalCount:N0} items!", Severity.Success);

                // Trigger data refresh
                await OnDataChanged.InvokeAsync();
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Delta import completion failed");
                Snackbar.Add($"Delta import failed: {ex.Message}", Severity.Error);
            }
            finally
            {
                _isImporting = false;
            }

            return;
        }

        // Handle full mode completion (temp database swap)
        if (_tempDbContext is null)
        {
            return;
        }

        try
        {
            // Commit transaction
            if (_importTransaction is not null)
            {
                Logger.LogInformation("Committing import transaction");
                await _importTransaction.CommitAsync();
                await _importTransaction.DisposeAsync();
                _importTransaction = null;
            }

            // Validate imported data
            var importedCount = await _tempDbContext.TodoItems.CountAsync();
            Logger.LogInformation("Import validation: {ImportedCount} items in temporary database", importedCount);

            if (importedCount != totalCount)
            {
                throw new InvalidOperationException($"Data validation failed: expected {totalCount} items, got {importedCount}");
            }

            // Rebuild FTS5 index to populate it with imported data
            Logger.LogDebug("Rebuilding FTS5 index for imported data");
            await _tempDbContext.RebuildTodoItemFts5IndexAsync();

            // Dispose temp context to close connection
            await _tempDbContext.DisposeAsync();
            _tempDbContext = null;

            // Close both databases before swap to ensure clean file handles
            Logger.LogDebug("Closing import database: {DatabaseName}", ImportDatabaseName);
            await SqliteWasmWorkerBridge.Instance.CloseDatabaseAsync(ImportDatabaseName);

            Logger.LogDebug("Closing main database: {DatabaseName}", DatabaseName);
            await SqliteWasmWorkerBridge.Instance.CloseDatabaseAsync(DatabaseName);

            // Perform atomic file swap in OPFS using native rename (metadata-only, no file copy)
            Logger.LogInformation("Performing database backup and swap");
            await SwapDatabasesAsync(DatabaseName, ImportDatabaseName, BackupDatabaseName, Logger);

            // Create auto checkpoint after full import (database has been swapped)
            await using var newContext = await DbContextFactory.CreateDbContextAsync();
            var checkpoint = await newContext.CreateCheckpointAsync(
                $"Auto checkpoint after full import ({totalCount} items)",
                "Auto");

            Logger.LogInformation("Created checkpoint after full import at {CheckpointTime}", checkpoint.CreatedAt);

            Snackbar.Add($"Successfully imported {totalCount:N0} items!", Severity.Success);

            // Trigger data refresh - EF Core will auto-reconnect to the new database
            await OnDataChanged.InvokeAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Import completion failed");
            Snackbar.Add($"Import failed: {ex.Message}", Severity.Error);

            // Rollback transaction if active
            if (_importTransaction is not null)
            {
                await _importTransaction.RollbackAsync();
                await _importTransaction.DisposeAsync();
                _importTransaction = null;
            }

            // Cleanup temporary database
            if (_tempDbContext is not null)
            {
                await _tempDbContext.DisposeAsync();
                _tempDbContext = null;
            }

            await OnImportFailed(ex.Message);
        }
        finally
        {
            _isImporting = false;
        }
    }

    private async Task OnImportFailed(string error)
    {
        Logger.LogError("Import failed: {Error}", error);

        // Rollback and dispose transaction if active
        if (_importTransaction is not null)
        {
            try
            {
                await _importTransaction.RollbackAsync();
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Transaction rollback failed");
            }
            finally
            {
                await _importTransaction.DisposeAsync();
                _importTransaction = null;
            }
        }

        // Cleanup temporary database context
        if (_tempDbContext is not null)
        {
            await _tempDbContext.DisposeAsync();
            _tempDbContext = null;
        }

        try
        {
            // Delete temporary database file
            Logger.LogDebug("Cleaning up temporary import database");
            if (await SqliteWasmWorkerBridge.Instance.ExistsDatabaseAsync(ImportDatabaseName))
            {
                await SqliteWasmWorkerBridge.Instance.DeleteDatabaseAsync(ImportDatabaseName);
                Logger.LogDebug("Deleted temporary database: {DatabaseName}", ImportDatabaseName);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Cleanup failed");
        }

        _isImporting = false;
    }

    [SupportedOSPlatform("browser")]
    private static async Task SwapDatabasesAsync(string mainDbName, string importDbName, string backupDbName, ILogger logger)
    {
        // Atomic file swap using OPFS operations:
        // 1. Delete old backup if exists
        // 2. Delete current db (or rename to backup if needed)
        // 3. Rename import db -> current

        try
        {
            var bridge = SqliteWasmWorkerBridge.Instance;

            // Step 1: Delete old backup if it exists
            if (await bridge.ExistsDatabaseAsync(backupDbName))
            {
                logger.LogDebug("Deleting old backup database: {BackupDatabase}", backupDbName);
                await bridge.DeleteDatabaseAsync(backupDbName);
            }

            // Step 2: Check if main database exists in OPFS
            // Note: The main database might not exist in OPFS if it was only used by EF Core
            var mainDbExists = await bridge.ExistsDatabaseAsync(mainDbName);
            logger.LogDebug("Main database exists in OPFS: {Exists}", mainDbExists);

            if (mainDbExists)
            {
                // Rename current database to backup for safety
                logger.LogDebug("Renaming current database to backup: {MainDatabase} → {BackupDatabase}", mainDbName, backupDbName);
                await bridge.RenameDatabaseAsync(mainDbName, backupDbName);
            }
            else
            {
                // Main database doesn't exist in OPFS yet (created by import/initial setup)
                logger.LogDebug("Main database doesn't exist in OPFS, will be created by import");
            }

            // Step 3: Rename import database to main
            logger.LogDebug("Renaming import database to main: {ImportDatabase} → {MainDatabase}", importDbName, mainDbName);
            await bridge.RenameDatabaseAsync(importDbName, mainDbName);

            logger.LogInformation("Database swap completed: {MainDatabase} is now active{Backup}",
                mainDbName,
                mainDbExists ? $", backup saved as {backupDbName}" : "");
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Database swap failed");
            throw new InvalidOperationException($"Failed to swap databases. Your data may still be in the import database ({importDbName}).", ex);
        }
    }

    /// <summary>
    /// Permanently removes soft-deleted items (tombstones) from the database.
    /// Should only be called after successful delta export to ensure deleted items are synced.
    /// </summary>
    private async Task CleanTombstonesAsync()
    {
        try
        {
            await using var context = await DbContextFactory.CreateDbContextAsync();

            // Get all soft-deleted items
            var tombstones = await context.TodoItems
                .Where(t => t.IsDeleted)
                .ToListAsync();

            if (tombstones.Count == 0)
            {
                Snackbar.Add("No tombstones found to clean", Severity.Info);
                _showTombstoneCleanup = false;
                _tombstoneCount = 0;
                return;
            }

            var count = tombstones.Count;

            // Permanently delete tombstones
            context.TodoItems.RemoveRange(tombstones);
            await context.SaveChangesAsync();

            Logger.LogInformation("Cleaned {Count} tombstones from database", count);
            Snackbar.Add($"Successfully removed {count:N0} tombstone(s)", Severity.Success);

            // Hide cleanup banner
            _showTombstoneCleanup = false;
            _tombstoneCount = 0;

            // Trigger data refresh to update UI
            await OnDataChanged.InvokeAsync();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to clean tombstones");
            Snackbar.Add($"Failed to clean tombstones: {ex.Message}", Severity.Error);
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_tempDbContext is not null)
        {
            await _tempDbContext.DisposeAsync();
        }
    }
}
