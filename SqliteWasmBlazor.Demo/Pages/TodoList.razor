@page "/todos"
@using Microsoft.EntityFrameworkCore
@using System.Diagnostics
@using SqliteWasmBlazor.Models
@using SqliteWasmBlazor.Models.Models
@using SqliteWasmWorkerBridge = SqliteWasmBlazor.SqliteWasmWorkerBridge
@inject IDbContextFactory<TodoDbContext> DbContextFactory
@inject ISnackbar Snackbar

<PageTitle>Todo List</PageTitle>

@if (_isGenerating)
{
    <MudOverlay Visible="true" ZIndex="9999" DarkBackground="true" Absolute="false">
        <MudPaper Class="pa-8" Elevation="8" Style="max-width: 400px;">
            <MudStack Spacing="4" AlignItems="AlignItems.Center">
                <MudProgressCircular Color="Color.Primary" Size="Size.Large" Indeterminate="true" />
                <MudText Typo="Typo.h6" Align="Align.Center">Generating Test Data</MudText>
                <MudText Typo="Typo.body2" Align="Align.Center" Color="Color.Secondary">
                    Creating @_generatedFakeEntries.ToString("N0") entries...
                </MudText>
                <MudText Typo="Typo.caption" Align="Align.Center" Color="Color.Secondary">
                    Please wait, this may take a moment
                </MudText>
            </MudStack>
        </MudPaper>
    </MudOverlay>
}

<MudContainer MaxWidth="MaxWidth.Large" Class="mt-4">
    <MudText Typo="Typo.h3" GutterBottom="true">
        <MudIcon Icon="@Icons.Material.Filled.Storage" Class="mr-2" />
        SqliteWasmBlazor Todo List
    </MudText>
    <MudText Typo="Typo.body1" Color="Color.Secondary" Class="mb-6">
        Persistent storage using SQLite WASM with OPFS - Data survives page refresh!
    </MudText>

    <!-- Add New Todo Card -->
    <MudPaper Elevation="2" Class="pa-4 mb-6">
        <MudText Typo="Typo.h6" Class="mb-3">
            <MudIcon Icon="@Icons.Material.Filled.Add" Size="Size.Small" Class="mr-1" />
            Add New Todo
        </MudText>
        <MudGrid>
            <MudItem xs="12" sm="4">
                <MudTextField @bind-Value="_newTitle"
                              Label="Title"
                              Variant="Variant.Outlined"
                              Required="true"
                              Immediate="true"
                              OnKeyDown="HandleKeyDownAsync" />
            </MudItem>
            <MudItem xs="12" sm="6">
                <MudTextField @bind-Value="_newDescription"
                              Label="Description"
                              Variant="Variant.Outlined"
                              OnKeyDown="HandleKeyDownAsync" />
            </MudItem>
            <MudItem xs="12" sm="2">
                <MudButton Variant="Variant.Filled"
                           Color="Color.Primary"
                           OnClick="AddTodoAsync"
                           FullWidth="true"
                           StartIcon="@Icons.Material.Filled.Add"
                           Size="Size.Large">
                    Add
                </MudButton>
            </MudItem>
        </MudGrid>
    </MudPaper>

    <!-- Search and Performance Testing Card -->
    <MudPaper Elevation="2" Class="pa-4 mb-6">
        <MudText Typo="Typo.h6" Class="mb-3">
            <MudIcon Icon="@Icons.Material.Filled.Speed" Size="Size.Small" Class="mr-1" />
            Search & Performance Testing
        </MudText>
        <MudStack Spacing="3">
            <MudTextField T="string"
                          Value="_searchString"
                          ValueChanged="@(s => OnSearch(s))"
                          Immediate="true"
                          Label="Search"
                          Variant="Variant.Outlined"
                          Placeholder="Search by title or description..."
                          Adornment="Adornment.Start"
                          AdornmentIcon="@Icons.Material.Filled.Search"
                          Clearable="true" />

            <MudGrid Spacing="2">
                <MudItem xs="12" sm="6" md="3" Class="d-flex align-center">
                    <MudSelect T="int"
                               @bind-Value="_generatedFakeEntries"
                               Label="Number of Entries"
                               Variant="Variant.Outlined"
                               Dense="true"
                               FullWidth="true"
                               Disabled="_isGenerating">
                        <MudSelectItem Value="10000">10,000</MudSelectItem>
                        <MudSelectItem Value="100000">100,000</MudSelectItem>
                        <MudSelectItem Value="1000000">1,000,000</MudSelectItem>
                    </MudSelect>
                </MudItem>
                <MudItem xs="12" sm="6" md="3" Class="d-flex align-center">
                    <MudButton Variant="Variant.Filled"
                               Color="Color.Secondary"
                               OnClick="CreateTestDataAsync"
                               StartIcon="@Icons.Material.Filled.PlayArrow"
                               Disabled="_isGenerating"
                               FullWidth="true">
                        @if (_isGenerating)
                        {
                            <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                            @:Generating...
                        }
                        else
                        {
                            @:Generate
                        }
                    </MudButton>
                </MudItem>
                <MudItem xs="12" sm="6" md="3" Class="d-flex align-center">
                    <MudButton Variant="Variant.Outlined"
                               Color="Color.Error"
                               OnClick="ClearAllDataAsync"
                               StartIcon="@Icons.Material.Filled.DeleteSweep"
                               FullWidth="true"
                               Disabled="_isGenerating">
                        Clear All
                    </MudButton>
                </MudItem>
                <MudItem xs="12" sm="6" md="3" Class="d-flex align-center">
                    <MudButton Variant="Variant.Outlined"
                               Color="Color.Warning"
                               OnClick="ResetDatabaseAsync"
                               StartIcon="@Icons.Material.Filled.RestartAlt"
                               FullWidth="true"
                               Disabled="_isGenerating">
                        Reset Database
                    </MudButton>
                </MudItem>
            </MudGrid>

            @if (!string.IsNullOrEmpty(_performanceInfo))
            {
                <MudAlert Severity="Severity.Success" Variant="Variant.Outlined">
                    @_performanceInfo
                </MudAlert>
            }
        </MudStack>
    </MudPaper>

    <!-- Todo List Table -->
    <MudPaper Elevation="2" Class="pa-4 mb-6">
        <MudText Typo="Typo.h6" Class="mb-3">
            <MudIcon Icon="@Icons.Material.Filled.List" Size="Size.Small" Class="mr-1" />
            Todo Items (@_totalCount)
            @if (!string.IsNullOrWhiteSpace(_searchString))
            {
                <MudChip T="string" Size="Size.Small" Color="Color.Primary" OnClose="ClearSearchAsync">
                    Filtered: @_searchString
                </MudChip>
            }
        </MudText>

        <MudTable ServerData="LoadServerDataAsync"
                  Hover="true"
                  Breakpoint="Breakpoint.Sm"
                  Dense="true"
                  @ref="Table">
            <HeaderContent>
                <MudTh>Status</MudTh>
                <MudTh>Title</MudTh>
                <MudTh>Description</MudTh>
                <MudTh>Created</MudTh>
                <MudTh Style="text-align: right;">Actions</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd DataLabel="Status">
                    <MudCheckBox T="bool"
                                 Value="@context.IsCompleted"
                                 ValueChanged="async (_) => await ToggleCompleteAsync(context)"
                                 Color="Color.Success" />
                </MudTd>
                <MudTd DataLabel="Title">
                    <MudText Typo="Typo.body2"
                             Style="@(context.IsCompleted ? "text-decoration: line-through; color: var(--mud-palette-text-secondary);" : "")">
                        @context.Title
                    </MudText>
                </MudTd>
                <MudTd DataLabel="Description">
                    <MudText Typo="Typo.body2"
                             Style="@(context.IsCompleted ? "text-decoration: line-through; color: var(--mud-palette-text-secondary);" : "")">
                        @context.Description
                    </MudText>
                </MudTd>
                <MudTd DataLabel="Created">
                    <MudChip T="string" Size="Size.Small" Variant="Variant.Text">
                        @context.CreatedAt.ToString("g")
                    </MudChip>
                </MudTd>
                <MudTd DataLabel="Actions" Style="text-align: right;">
                    <MudIconButton Icon="@Icons.Material.Filled.Delete"
                                   Color="Color.Error"
                                   Size="Size.Small"
                                   OnClick="async () => await DeleteTodoAsync(context)" />
                </MudTd>
            </RowTemplate>
            <NoRecordsContent>
                <MudText>No todos yet. Add one above to get started!</MudText>
            </NoRecordsContent>
            <PagerContent>
                <MudTablePager PageSizeOptions="[10, 25, 50, 100]" />
            </PagerContent>
        </MudTable>
    </MudPaper>

    <!-- Database Info Card -->
    <MudPaper Elevation="2" Class="pa-4">
        <MudGrid>
            <MudItem xs="12" sm="8">
                <MudText Typo="Typo.h6" Class="mb-2">
                    <MudIcon Icon="@Icons.Material.Filled.Info" Size="Size.Small" Class="mr-1" />
                    Database Information
                </MudText>
                <MudStack Spacing="2">
                    <MudStack Row="true" AlignItems="AlignItems.Center">
                        <MudIcon Icon="@Icons.Material.Filled.TableChart" Size="Size.Small" />
                        <MudText Typo="Typo.body2">
                            <strong>Total Items:</strong> @_totalCount
                        </MudText>
                    </MudStack>
                    <MudStack Row="true" AlignItems="AlignItems.Center">
                        <MudIcon Icon="@Icons.Material.Filled.DataUsage" Size="Size.Small" />
                        <MudText Typo="Typo.body2">
                            <strong>Database Size:</strong> @FormatBytes(_databaseFileSize)
                        </MudText>
                    </MudStack>
                    <MudStack Row="true" AlignItems="AlignItems.Center">
                        <MudIcon Icon="@Icons.Material.Filled.Storage" Size="Size.Small" />
                        <MudText Typo="Typo.body2">
                            <strong>Storage:</strong> OPFS (Origin Private File System)
                        </MudText>
                    </MudStack>
                    <MudStack Row="true" AlignItems="AlignItems.Center">
                        <MudIcon Icon="@Icons.Material.Filled.CheckCircle" Size="Size.Small" />
                        <MudText Typo="Typo.body2">
                            <strong>Persistence:</strong> Data survives page refresh!
                        </MudText>
                    </MudStack>
                </MudStack>
            </MudItem>
            <MudItem xs="12" sm="4" Style="display: flex; align-items: center; justify-content: center;">
                <MudButton Variant="Variant.Filled"
                           Color="Color.Success"
                           OnClick="RefreshListAsync"
                           StartIcon="@Icons.Material.Filled.Refresh"
                           Size="Size.Large">
                    Refresh List
                </MudButton>
            </MudItem>
        </MudGrid>
    </MudPaper>
</MudContainer>

@code {
    public required MudTable<TodoItem> Table;
    private int _totalCount;
    private long _databaseFileSize;
    private string _newTitle = string.Empty;
    private string _newDescription = string.Empty;
    private string _searchString = string.Empty;
    private string _performanceInfo = string.Empty;
    private bool _isGenerating;
    private int _generatedFakeEntries = 10000;

    private static readonly string[] TaskPrefixes = ["Task", "Work", "Project", "Meeting", "Call", "Email", "Review", "Plan", "Design", "Test"];
    private static readonly string[] TaskTypes = ["urgent", "important", "routine", "followup", "research", "development", "documentation", "deployment"];
    private static readonly Random Random = new();

    protected override async Task OnInitializedAsync()
    {
        await UpdateTotalCountAsync();
        await UpdateDatabaseFileSizeAsync();
    }

    private async Task<TableData<TodoItem>> LoadServerDataAsync(TableState state, CancellationToken cancellationToken)
    {
        await using var context = await DbContextFactory.CreateDbContextAsync(cancellationToken);

        var query = context.TodoItems.AsQueryable();

        // Apply search filter if active
        if (!string.IsNullOrWhiteSpace(_searchString))
        {
            query = query.Where(t => t.Title.StartsWith(_searchString) || t.Description.Contains(_searchString));
        }

        query = query.OrderByDescending(t => t.CreatedAt);

        // Get fresh count for accurate paging
        var count = await query.CountAsync(cancellationToken);
        _totalCount = count;

        var data = await query
            .Skip(state.Page * state.PageSize)
            .Take(state.PageSize)
            .ToListAsync(cancellationToken);

        return new TableData<TodoItem>
        {
            Items = data,
            TotalItems = count
        };
    }

    private async Task UpdateTotalCountAsync()
    {
        await using var context = await DbContextFactory.CreateDbContextAsync();

        var query = context.TodoItems.AsQueryable();

        // Apply search filter if active
        if (!string.IsNullOrWhiteSpace(_searchString))
        {
            query = query.Where(t => t.Title.StartsWith(_searchString) || t.Description.Contains(_searchString));
        }

        _totalCount = await query.CountAsync();
        StateHasChanged();
    }

    private async Task UpdateDatabaseFileSizeAsync()
    {
        try
        {
            await using var context = await DbContextFactory.CreateDbContextAsync();
            var fileSize = await context.Database.SqlQueryRaw<long>(
                "SELECT (SELECT page_count FROM pragma_page_count()) * (SELECT page_size FROM pragma_page_size()) AS Value"
            ).FirstOrDefaultAsync();
            _databaseFileSize = fileSize;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Failed to get database file size: {ex.Message}");
            _databaseFileSize = 0;
        }
    }

    private static string FormatBytes(long bytes)
    {
        if (bytes < 1024)
        {
            return $"{bytes} B";
        }
        if (bytes < 1024 * 1024)
        {
            return $"{bytes / 1024.0:F2} KB";
        }
        if (bytes < 1024 * 1024 * 1024)
        {
            return $"{bytes / (1024.0 * 1024.0):F2} MB";
        }
        return $"{bytes / (1024.0 * 1024.0 * 1024.0):F2} GB";
    }

    private async Task AddTodoAsync()
    {
        if (string.IsNullOrWhiteSpace(_newTitle))
        {
            Snackbar.Add("Please enter a title", Severity.Warning);
            return;
        }

        var stopwatch = Stopwatch.StartNew();

        var todo = new TodoItem
        {
            Title = _newTitle,
            Description = _newDescription,
            CreatedAt = DateTime.UtcNow,
            IsCompleted = false
        };

        await using var context = await DbContextFactory.CreateDbContextAsync();
        context.TodoItems.Add(todo);
        await context.SaveChangesAsync();

        stopwatch.Stop();

        _newTitle = string.Empty;
        _newDescription = string.Empty;

        await Table.ReloadServerData();
        await UpdateDatabaseFileSizeAsync();
        Snackbar.Add($"Todo created in {stopwatch.ElapsedMilliseconds}ms", Severity.Success);
    }

    private async Task ToggleCompleteAsync(TodoItem todo)
    {
        var stopwatch = Stopwatch.StartNew();

        todo.IsCompleted = !todo.IsCompleted;
        todo.CompletedAt = todo.IsCompleted ? DateTime.UtcNow : null;

        await using var context = await DbContextFactory.CreateDbContextAsync();
        context.TodoItems.Update(todo);
        await context.SaveChangesAsync();

        stopwatch.Stop();

        await Table.ReloadServerData();
        var action = todo.IsCompleted ? "completed" : "reopened";
        Snackbar.Add($"Todo {action} in {stopwatch.ElapsedMilliseconds}ms", Severity.Info);
    }

    private async Task DeleteTodoAsync(TodoItem todo)
    {
        var stopwatch = Stopwatch.StartNew();

        await using var context = await DbContextFactory.CreateDbContextAsync();
        context.TodoItems.Remove(todo);
        await context.SaveChangesAsync();

        stopwatch.Stop();

        await Table.ReloadServerData();
        await UpdateDatabaseFileSizeAsync();
        Snackbar.Add($"Todo deleted in {stopwatch.ElapsedMilliseconds}ms", Severity.Error);
    }

    private async Task RefreshListAsync()
    {
        var stopwatch = Stopwatch.StartNew();

        await Table.ReloadServerData();
        await UpdateDatabaseFileSizeAsync();

        stopwatch.Stop();

        Snackbar.Add($"List refreshed in {stopwatch.ElapsedMilliseconds}ms", Severity.Info);
    }

    private async Task HandleKeyDownAsync(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await AddTodoAsync();
        }
    }

    private async Task CreateTestDataAsync()
    {
        _isGenerating = true;
        _performanceInfo = string.Empty;
        StateHasChanged();

        var stopwatch = Stopwatch.StartNew();

        await using var context = await DbContextFactory.CreateDbContextAsync();

        // Generate all items first
        var items = new List<TodoItem>();
        for (int i = 0; i < _generatedFakeEntries; i++)
        {
            var prefix = TaskPrefixes[Random.Next(TaskPrefixes.Length)];
            var type = TaskTypes[Random.Next(TaskTypes.Length)];

            items.Add(new TodoItem
            {
                Title = $"{prefix} #{i + 1}",
                Description = $"{type} task - {Guid.NewGuid()}",
                CreatedAt = DateTime.UtcNow.AddMinutes(-Random.Next(10000)),
                IsCompleted = Random.Next(100) < 30
            });
        }

        // Use raw SQL with multi-row INSERT for true batching
        // SQLite supports up to 999 parameters per statement, so with 5 columns we can insert ~199 rows per statement
        using var transaction = await context.Database.BeginTransactionAsync();
        try
        {
            const int rowsPerBatch = 199; // 199 rows * 5 columns = 995 parameters (under SQLite's 999 limit)
            var batchCount = 0;

            for (int i = 0; i < items.Count; i += rowsPerBatch)
            {
                var batch = items.Skip(i).Take(rowsPerBatch).ToList();

                // Build multi-row INSERT statement
                var valuesClauses = new List<string>();
                var parameters = new List<object?>();

                for (int j = 0; j < batch.Count; j++)
                {
                    var item = batch[j];
                    var baseIndex = j * 5;
                    valuesClauses.Add($"({{{baseIndex}}}, {{{baseIndex + 1}}}, {{{baseIndex + 2}}}, {{{baseIndex + 3}}}, {{{baseIndex + 4}}})");

                    parameters.Add(item.Title);
                    parameters.Add(item.Description);
                    parameters.Add(item.CreatedAt);
                    parameters.Add(item.IsCompleted ? 1 : 0);
                    parameters.Add(item.CompletedAt?.ToString("O"));
                }

                var sql = $@"
                    INSERT INTO TodoItems (Title, Description, CreatedAt, IsCompleted, CompletedAt)
                    VALUES {string.Join(", ", valuesClauses)}";

                await context.Database.ExecuteSqlRawAsync(sql, parameters.ToArray()!);
                batchCount++;
            }

            await transaction.CommitAsync();

            stopwatch.Stop();

            var itemsPerSecond = _generatedFakeEntries / stopwatch.Elapsed.TotalSeconds;
            _performanceInfo = $"Generated {_generatedFakeEntries:N0} entries in {stopwatch.ElapsedMilliseconds}ms ({itemsPerSecond:F0} items/sec) - {batchCount} SQL batches";
            _isGenerating = false;

            await Table.ReloadServerData();
            await UpdateDatabaseFileSizeAsync();
            StateHasChanged();
            Snackbar.Add($"Generated {_generatedFakeEntries:N0} entries in {stopwatch.ElapsedMilliseconds}ms ({batchCount} SQL batches)", Severity.Success);
        }
        catch (Exception ex)
        {
            await transaction.RollbackAsync();
            _isGenerating = false;
            Snackbar.Add($"Generation failed: {ex.Message}", Severity.Error);
            throw;
        }
    }

    private async Task OnSearch(string text)
    {
        _searchString = text;
        await Table.ReloadServerData();
        StateHasChanged();
    }

    private async Task ClearSearchAsync()
    {
        _searchString = string.Empty;
        await Table.ReloadServerData();
        _performanceInfo = string.Empty;
        StateHasChanged();
    }

    private async Task ClearAllDataAsync()
    {
        var stopwatch = Stopwatch.StartNew();

        await using var context = await DbContextFactory.CreateDbContextAsync();
        await context.Database.ExecuteSqlRawAsync("DELETE FROM TodoItems");

        stopwatch.Stop();

        await UpdateTotalCountAsync();
        await UpdateDatabaseFileSizeAsync();
        await Table.ReloadServerData();
        _performanceInfo = $"All data cleared in {stopwatch.ElapsedMilliseconds}ms";
        Snackbar.Add($"All todos deleted in {stopwatch.ElapsedMilliseconds}ms", Severity.Warning);
    }

    private async Task ResetDatabaseAsync()
    {
        var stopwatch = Stopwatch.StartNew();

        try
        {
            // Delete the database file from OPFS SAHPool
            await SqliteWasmWorkerBridge.Instance.DeleteDatabaseAsync("TodoDb.db");

            // Recreate database schema
            await using var context = await DbContextFactory.CreateDbContextAsync();
            await context.Database.EnsureCreatedAsync();

            stopwatch.Stop();

            await UpdateTotalCountAsync();
            await UpdateDatabaseFileSizeAsync();
            await Table.ReloadServerData();
            _performanceInfo = $"Database reset in {stopwatch.ElapsedMilliseconds}ms";
            Snackbar.Add($"Database completely reset in {stopwatch.ElapsedMilliseconds}ms", Severity.Warning);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Database reset failed: {ex.Message}", Severity.Error);
        }
    }
}
